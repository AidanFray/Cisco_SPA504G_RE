# Session 2

## `validate_firmware_header`

Started looking at the `validate_firmware_header` function to start RE the firmware header format.

We learned due to things such as `memcmp` that the `digest` and `randseq` are at offsets `0x30` and `0x40` respectivly.

The `digest` is created by `gen_fmhdr_digest` and the `randseq` is generated by `gen_fmhdr_nsdigest`. We'll come back to these when we need them.

There is also the line:

```C
iVar3 = header->sector_offset??? + header->field88_0x7c * header->field51_0x54;
```

Where `iVar3` is passed as a length to the digest functions. One of these members is sector count and the other is a sector size. We'll keep this in mind...

## `libupg_validate_firmware_mem`

We can see that a "sector header" is 0x40 bytes long from the following `memcpy`:

```c
memcpy(&sector_header_s,head_off_ptr,0x40);
```

We now know that:

- The first sector starts at `0x80`
- Sector headers are `0x40` in 
- Sector header has a "flag" that is stored in 2 bytes
    - Bit 0 represents the "Compressed" state. If it's set to zero
      the sector is compressed.
- A sector has a digest at offset `0xC`


## `uncompress`

Found a function that decompresses the firmware. Important to learn that `inflate` is the compression algorithm used.

```c
Var1 = inflateInit2(&local_50,0xf);
if (iVar1 == 0) {
iVar1 = inflate(&local_50,4);
if (iVar1 == 1) {
    *param_2 = local_3c;
    iVar1 = inflateEnd(&local_50);
}
else {
    inflateEnd(&local_50);
    if (iVar1 == 0) {
    iVar1 = -5;
    }
}
}
```

# Conclusion

Entire session was essentially Ghidra - we worked our way through the firmware and sector headers.

We're doing this so we can create a body of knowledge on the structure of the firmware so we can work out what we have. By the fact that the firmware is formatted into sectors shows that the firmware images allow for some sectors to be flashed and others to be ignored. This probably results in us not having a full firmware image...
